## КОМБИНАТОРНЫЕ СЕЛЕКТОРЫ И СЕЛЕКТОРЫ ПО АТРИБУТАМ
- **порядок применения псевдоклассов**
    - __focus__
    - __hover__
    - __activ__

__через запятую__ == обращение к нескольким элементам
__пробел__ == все элементы внутри указанного элемента. если его нет - обращение по комбинации классов
дочерний __>__ применяется только к одному указанному эл-ту
__~__ == все соседние эл-ты указанного селектора
__+__ == следующий за собой соседний элемент
__a[href]__ == в этом случае проверяется наличие у ссылки атрибута [href], и только при его наличии применяется стиль. href можно прописать с содержанием (например адресом конкретного сайта), тогда __ТОЛЬКО__ при соблюдении этого условия будет применяться стиль
__a[href*="login"]__ == в этом случае выбираются только те элементы, в которых присутствует строка _login_. __[*]__ заменяет содержание, то есть оно может быть любым _(пример: a[href*="login"] применит стили к <a [href="https://site.com/login">)_
__a[hrerf^="http://"]__ == применится только к ссылкам, у которых атрибут __href НАЧИНИЕТСЯ__ с указанного значения
__a[hrerf$".pdf"]__ == применится только к ссылкам, у которых атрибут __href ЗАКАНЧИВАЕТСЯ__ указанным значением

## КЛЮЧЕВЫЕ СЛОВА В CSS
__initial__ == возвращает стили к своему __изначальному__ значению, по умолчанию 
__inherit__ == наследует стили от родителя
__unset__ == зависит от типа свойства, к которому применяется (наследуемое - сработает как _inherit_, если не наследуемое - как _initial_). _(пример адекватного использования - сброс всех стилей у какого-то элемента: <тэг class="class"> {__all: unset;__} - таким образом у конкретного элемента стили будут сброшены)_ 
__revert__ == аналог _unset_, но сбрасывает не к начальным, а браузерным значениям

## ПСЕВДОКЛАССЫ
(_.element:псевдокласс_ __ПРОБЕЛЫ ПРИ НАПИСАНИИ НЕДОПУСТИМЫ! ТОЛЬКО ОДНО ДВОЕТОЧНИЕ__)

__hover__ == производит действие (применение стиля) при наведении курсора
__focus__ == аналогично _hover_, но срабатывает при фокусе на элементе (через TAB или самостоятельном клике)
__activ__ == срабатывает при нажатии и удерживании мыши. __суммируется__ с _focus_
__checked__ == срабатывает, когда чек-бокс находится в активном состоянии
__disabled__ == делает элемент неактивным
__valid__ & __invalid__ == задает стили элементу если он прошел или не прошел валидацию (например можно подсказать, что поле для ввода заполнено не правильно)
__nth-child(цифра)__ == применяет стиль к __определенному__ _(цифра_) элементу в пределах своего родителя _(подробнее тут https://snipp.ru/html-css/nth-child)_ __ВАЖНО!__ возможно использование других подобных псевдоклассов (_first-child_ и _last-child_) __Дополнение:__ также возможно комбинировать предыдущие псевдоэлементы с __:not__!

## ПСЕВДОЭЛЕМЕНТЫ
(_при написании необходимо использовать два знака двоеточего! ::first-line_) 

__first-line__ == выбирает только первую __СТРОКУ__ в тексте
__first-line__ == выбирает первую __БУКВУ__
__placeholder__ == позволяет стилизовать подсказку инпута
__selection__ == позволяет управлять стилями выделения на сайте

### Самые часто применяемые псведоэлементы и варианты применения
#### Простейшая анимация

__before__ & __after__ == основное назначение - появляются, соответственно __до__ и __после__ блока. Работают __ТОЛЬКО__ при заданном свойстве ***content***, при этом оно также может быть ПУСТЫМ!. _Пример:_ 
.element::before {
	content:"Привет"; 
	display: block;
	}
Также эти элементы позволяют создавать "красоту" - плавный переход, эффект появления и прочее. Пример:
HTML:
<!-- <nav class="nav">
  <ul class="nav__list">
    <li class="nav__item"><a href="#" class="nav__link">text</a></li>
    <li class="nav__item"><a href="#" class="nav__link">text</a></li>
    <li class="nav__item"><a href="#" class="nav__link">text</a></li>
    <li class="nav__item"><a href="#" class="nav__link">text</a></li>
    <li class="nav__item"><a href="#" class="nav__link">text</a></li>
  </ul>
</nav> -->
CSS:
<!-- a {
  text-decoration: none;
  color: #333;
}
.nav__list {
  list-style: none;
  display: flex;
}
.nav__item:not(:last-child) {
  margin-right: 20px;
}
.nav__link {
  position: relative;
}
.nav__link::after {
  content: "";
  position: absolute;
  left: 0;
  bottom: 0;
  width: 100%;
  height: 2px;
  background-color: #333;
  transform: scaleX(0);
  transition: transform 0.3s;
}
.nav__link:hover::after {
  transform: scale(1);
}. -->
Если запустить этот код, то у ссылок, при наведении на них курсора, снизу из центра плавно появляется подчеркивание. За плавность отвечает __transition: transform 0.3s__. 

### Использование счетчика 
HTML: 
<!-- <ol>
  <li>text</li>
  <li>text</li>
  <li>text</li>
  <li>text</li>
  <li>text</li>
</ol> -->
CSS:
<!-- ol {
  counter-reset: section; 
  list-style: none;
}
li::before {
  counter-increment: section;
  content: "0" counter(section) ": ";
} -->
Здесь _counter-reset_ определяет переменную _section_ (наименование переменной произвольное).
_increment_ дословно "прирост", то есть увеличение счетчика (по аналогии с C#, где было n++)
далее через _content_ задается "0" и счетчик. Также по аналогии с C# будут выдаваться неразрывные строки, в которые передается "0" и значение счетчика (__проверено, получается 010 и т.д.__), при этом все, что идет в каывчках заменяет содержимое списка.

### Задание бэкграунда

HTML:
<!-- <a href="">text</a> -->
CSS:
<!-- a::before {
  content: "";
  display: inline-block;
  margin-right: 5px;
  width: 10px;
  height: 10px;
  background-image: url(https://image.flaticon.com/icons/png/512/545/545680.png);
  background-size: cover;
  background-repeat: no-repeat;
} -->

таким образом у ссылки слева отобразится стрелка назад

### Изменение стилей элементов при взаимодействии с пользователем 
***смотри урок с Lionic***

## ПЕРЕМЕННЫЕ В CSS

__:root__ == псевдокласс, который определяет, что значения переменных могут быть использованы любым элементом в коде
_пример написания:_
:root {
	--имя-переменной: значение_переменной;
	--yellow-color: #FCBA03;
	--font-size: 20px;
}
переменную можно также объявить внутри класса:
_например:_
.element {
	--yellow-color: #FCBA03;
}
__однако такая переменная недоступна вне этого класса__

для того, чтобы применить значение записанной переменной используется ключевое слово __var__.
_пример:_
.element {
	color: var(--yellow-color);
	font-size: var(--text-size);
}

Использование переменных также возможно при работе с адаптивом, через медиа запросы:
@media (max-width: 600px) {
	:root{
		--text-size: 10px;
	}
} в данном _примере_ при изменении размера экрана меньше 600px размер шрифта станет 10px.